# -*- coding: utf-8 -*-
"""health Bar

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qkg0VftkHGTaYh_47m_bQMR_ui0tODSN
"""

#from google.colab import drive

#drive.mount('/content/gdrive/')

import cv2
import numpy as np
#from google.colab.patches import cv2_imshow

def get_video_frames_dimensions(videoURL):
  height,width,depth = -1,-1,-1
  cap = cv2.VideoCapture(videoURL)
  if cap.isOpened()== False: 
    print("Error opening video stream or file")
  if cap.isOpened():
    ret, frame = cap.read()
    if ret == True:
       height=frame.shape[0]
       width=frame.shape[1]
       depth=frame.shape[2]
  cap.release()
  cv2.destroyAllWindows()
  return height,width,depth

def candidates_rect(lines):
  if lines is None:
    return []
  cand = []
  sorted_lines = []
  for line in lines:
    x1,y1,x2,y2 = line[0]
    if y1==y2:
      sorted_lines.append((y1,x1,x2))
  #sorted_lines.sort(key=lambda y: y[0])
  for i in range(len(sorted_lines)-1):
    fy,fx1,fx2 = sorted_lines[i]
    for j in range(i+1,len(sorted_lines)):
      sy,sx1,sx2 = sorted_lines[j]
      len1=abs(fx1-fx2)
      len2=abs(sx1-sx2)
      c1= abs(len1-len2) <10
      interx1 =max(min(fx1,fx2),min(sx1,sx2))
      interx2 =min(max(fx1,fx2),max(sx1,sx2))
      leninter=interx2-interx1 
      c2= leninter/len1>0.8 and leninter/len2>0.8 
      c3= abs(fy-sy)>=10
      c4= len1>=8*abs(fy-sy)
      #c5= len1<=18*abs(fy-sy)
      if c1 and c2 and c3 and c4:
        if fy>sy:
          cand.append((fy,fx1,fx2,sy,sx1,sx2))
        else:
          cand.append((sy,sx1,sx2,fy,fx1,fx2))
  return cand

def bar1_is_same_bar2(bar1,bar2):
  fy1,fx11,fx21,sy1,sx11,sx21 = bar1
  fy2,fx12,fx22,sy2,sx12,sx22 = bar2
  if abs(fy1-fy2)>5 or abs(sy1-sy2)>5:
    return False
  len1=abs(fx11-fx21)
  len2=abs(fx12-fx22)
  interx1 =max(min(fx11,fx21),min(fx12,fx22))
  interx2 =min(max(fx11,fx21),max(fx12,fx22))
  leninter=interx2-interx1 
  
  c1 = leninter/len1 > 0.2 or leninter/len2 > 0.2

  Slen1=abs(sx11-sx21)
  Slen2=abs(sx12-sx22)
  Sinterx1 =max(min(sx11,sx21),min(sx12,sx22))
  Sinterx2 =min(max(sx11,sx21),max(sx12,sx22))
  Sleninter=Sinterx2-Sinterx1 
  
  c2 = Sleninter/Slen1 > 0.2 or Sleninter/Slen2 > 0.2

  if c1 and c2:
    return True

  return False

def update_health_history(candidates,history,frameNumber):
  for pos in candidates:
    find = False
    for his in history:
      hisBox = [his[0],his[1],his[2],his[3],his[4],his[5]]
      if (bar1_is_same_bar2(hisBox,pos)):
        find = True
        his[1]=min(his[1],pos[1])
        his[2]=max(his[2],pos[2])
        his[4]=min(his[4],pos[4])
        his[5]=max(his[5],pos[5])
        his[7] = frameNumber
        break
    if not(find):
      history.append([pos[0],pos[1],pos[2],pos[3],pos[4],pos[5],frameNumber,frameNumber])

def get_health_bars(videoURL,NumberOfFramesToAvg):
  H,W,D = get_video_frames_dimensions(videoURL)
  cap = cv2.VideoCapture(videoURL)
  if (cap.isOpened()== False): 
    print("Error opening video stream or file")
  frameNumber = 0
  imageSum = np.zeros([H,W])
  buffer = []
  history = []
  while cap.isOpened() and NumberOfFramesToAvg != frameNumber:
    ret, frame = cap.read()
    frameNumber += 1
    if ret == True:
      image_gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
      filtered_image = cv2.Canny(image_gray,threshold1=100, threshold2=200)
      imageSum += filtered_image
      buffer.append(filtered_image)
    else:
      break
  mean = imageSum.copy()
  mean /= NumberOfFramesToAvg
  mean = np.array(mean, dtype = np.uint8)
  ret,thresholded = cv2.threshold(mean,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
  # closing = cv2.morphologyEx(thresholded,cv2.MORPH_CLOSE, np.ones((5,5),np.uint8))
  lines = cv2.HoughLinesP(thresholded,1,np.pi/2,100,minLineLength=60,maxLineGap=3)
  candidates = candidates_rect(lines)
  update_health_history(candidates, history,frameNumber-NumberOfFramesToAvg+1)

  while(cap.isOpened()):
    ret, frame = cap.read()
    frameNumber += 1
    if ret == True:
      imageSum -= buffer[0]
      image_gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
      filtered_image = cv2.Canny(image_gray,threshold1=100, threshold2=200)
      imageSum += filtered_image
      buffer.pop(0)
      buffer.append(filtered_image)
      
      mean = imageSum.copy()
      mean /= NumberOfFramesToAvg
      mean = np.array(mean, dtype = np.uint8)
      ret,thresholded = cv2.threshold(mean,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
      # closing = cv2.morphologyEx(thresholded,cv2.MORPH_CLOSE, np.ones((5,5),np.uint8))
      lines = cv2.HoughLinesP(thresholded,1,np.pi/2,100,minLineLength=60,maxLineGap=3)
      candidates = candidates_rect(lines)
      update_health_history(candidates, history,frameNumber-NumberOfFramesToAvg+1)

    else:      
      break
      
  while NumberOfFramesToAvg!=0:
    NumberOfFramesToAvg-=1
    update_health_history(candidates, history,frameNumber-NumberOfFramesToAvg+1)
    
  
  cap.release()
  cv2.destroyAllWindows()

  return history

def get_health_from_binary(binary,thresholded):
  counts = np.count_nonzero(binary ==255 , axis=1)
  isHealth = True
  for c in counts:
    if c!=1:
      isHealth = False
  white = np.count_nonzero(thresholded ==255)
  black = np.count_nonzero(thresholded ==0)
  if thresholded[0,0] ==0:
    isHealth = False
  if isHealth:
    return white/(white+black)
  else:
    return -1
  

def get_health_values(videoURL,NumberOfFramesToAvg):
  result = []
  healthbars = get_health_bars(videoURL,NumberOfFramesToAvg)
  healthbars.sort(key=lambda y: y[6])
  cap = cv2.VideoCapture(videoURL)
  if (cap.isOpened()== False): 
    print("Error opening video stream or file")
  frameNumber = 0
  detected = 0
  while(cap.isOpened()):
    ret, frame = cap.read()
    frameNumber += 1
    #if frameNumber>200:
      #break
    if ret == True:
      ans = 0
      cnt = 0
      for bar in healthbars:
        fy,fx1,fx2,sy,sx1,sx2,st,en = bar
        if frameNumber>=st:
          color_crop = frame[sy+2:fy-2,max(sx1,fx1)+2:min(sx2,fx2)-2]
          crop = cv2.cvtColor(color_crop,cv2.COLOR_BGR2GRAY)
          ret,thresholded = cv2.threshold(crop,80,255,cv2.THRESH_BINARY)
          edges = cv2.Canny(thresholded,threshold1=100, threshold2=200)
          H = get_health_from_binary(edges,thresholded)
          if H != -1:
            ans += (en-st+1)*H
            cnt += en-st+1
            #print(H)
            #cv2_imshow(color_crop)
            #cv2_imshow(edges)
      if ans == 0:
        result.append(1)
      else :
        detected+=1
        result.append(ans/cnt)
    else:
      break
  #print(detected)
  #print(frameNumber)
  cap.release()
  cv2.destroyAllWindows()
  return result

#res = get_health_values('/content/gdrive/MyDrive/third person shooter/realm royale_Trim.mp4',200)