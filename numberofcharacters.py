# -*- coding: utf-8 -*-
"""NumberOfCharacters.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yhzssUZk7TmpZEQCjUKddBXOW4wzj24o
"""

import warnings
warnings.filterwarnings('ignore')

"""#  -- INSTALL FACENET TO USE MTCNN MODEL (FACE DETECTION)"""

# !pip install facenet_pytorch

"""# -- LOADING YOLO (OBJECT DETECTION) AND MTCNN (FACE DETECTION)"""

import torch
from facenet_pytorch import MTCNN

yolo = torch.hub.load('ultralytics/yolov5', 'yolov5s')
mtcnn = MTCNN(keep_all=True)

"""# -- GET ACCESS TO GOOGLE DRIVE"""

# from google.colab import drive

# drive.mount('/content/gdrive/')

"""# -- HELPER FUNCTIONS

##### Create Video From Images and save it
"""

import cv2
import numpy as np

# take list of images, and save a video of this list in project folder
def createVideo(images): 
  height= images[0].shape[0]
  width= images[0].shape[1]
  fourcc = cv2.VideoWriter_fourcc(*'mp4v') 
  video = cv2.VideoWriter('video.avi', fourcc, 30, (width, height))

  for image in images:
     video.write(image)

  cv2.destroyAllWindows()
  video.release()

"""# -- GET DETECTED PERSONS USING YOLO"""

# take an image , return detected persons
def Get_Persons(img): 
    
    yolo.classes = [0]
    
    results = yolo(img)
    
    # results.show() # to show the image with detected objects
    
    return results

# take the result of YOLO, return pandas dataframe of that result
def getDataFrame(YOLOresult):
  return YOLOresult.pandas().xyxy[0]

"""# -- GET DETECTED FACES USING MTCNN"""

# take an image,return an array of bounding boxes of detected faces
# every element in this array is like : [xmin , ymin, xmax ,ymax]
def Get_Faces(img):
  boxes, probs, landmarks = mtcnn.detect(img, landmarks=True)
  return boxes

"""# -- GET EVERY PERSON WHO HAS FACE"""

# take person bounding box and face bounding box and return true if this face inside this person
def face_is_inside_person(person,face):
  xmin = max(face[0],person[0])
  xmax = min(face[2],person[2])
  ymin = max(face[1],person[1])
  ymax = min(face[3],person[3])
  
  xmax = max(xmax,xmin)
  ymax = max(ymax,ymin)

  area1 = (xmax-xmin)*(ymax-ymin)
  area2 = (face[2]-face[0])*(face[3]-face[1])
  return area1/area2 > 0.75

# take yolo result and mtcnn result and return a list of bounding boxes (persons have faces)
def get_persons_with_faces(YOLOresult,MTCNNresult):
  if YOLOresult is None:
    YOLOresult = []
  if MTCNNresult is None:
    MTCNNresult = []
  ret = []
  dataframe = getDataFrame(YOLOresult)
  for i in range(dataframe.shape[0]):
    xmin = dataframe.iloc[i]['xmin']
    xmax = dataframe.iloc[i]['xmax']
    ymin = dataframe.iloc[i]['ymin']
    ymax = dataframe.iloc[i]['ymax']
    person = [xmin,ymin,xmax,ymax]
    for face in MTCNNresult:
      if face_is_inside_person(person,face):
        ret.append(person)
  return ret

"""# -- GET STREAMERS BOUNDING BOXES"""

import cv2
import numpy as np

# take box1 and box2 and threshold,
# return true if the 2 boxes almost the same depending on thresold
def box2_is_same_box1(box1,box2,threshold):
  xmin = max(box1[0],box2[0])
  xmax = min(box1[2],box2[2])
  ymin = max(box1[1],box2[1])
  ymax = min(box1[3],box2[3])
  
  xmax = max(xmax,xmin)
  ymax = max(ymax,ymin)

  area1 = (xmax-xmin)*(ymax-ymin)
  area2 = (box1[2]-box1[0])*(box1[3]-box1[1])
  return area1/area2 > threshold

# helping funtion for get_streamers() function
def remove_old_history(clearAll,history,frameNumber,tolerence,minLength,streamers):
  Rem = []
  for his in history: 
    if frameNumber - his[5] - 1 > tolerence or clearAll:
      if his[5]-his[4]+1 >= minLength:
        streamers.append(his)
      Rem.append(his)
  for r in Rem:
    history.remove(r)
  Rem.clear()

# helping funtion for get_streamers() function
def update_history(possible,history,threshold,frameNumber):
  for pos in possible:
    find = False
    for his in history:
      hisBox = [his[0],his[1],his[2],his[3]]
      if (box2_is_same_box1(hisBox,pos,threshold)):
        find = True
        his[5] = frameNumber
        break
    if not(find):
      history.append([pos[0],pos[1],pos[2],pos[3],frameNumber,frameNumber])

# a streamer is a person with face who last in his position in screen for a while (many frames)
# THIS IS THE MAIN FUNCTION
def get_streamers(videoURL,tolerence,minLength,threshold,skip):
  # IM = []

  streamers = []
  cap = cv2.VideoCapture(videoURL)
  if (cap.isOpened()== False): 
    print("Error opening video stream or file")

  frameNumber = 0
  totalFrames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
  history = []
  while(cap.isOpened()):
    ret, frame = cap.read()
    frameNumber += 1
    
    if ret == True:
      if frameNumber % skip == 1 or frameNumber == totalFrames:
        frame_rgb = frame[..., ::-1]
        persons = Get_Persons(frame_rgb)
        faces = Get_Faces(frame_rgb)
        possible = get_persons_with_faces(persons,faces)
        
        remove_old_history(False,history,frameNumber,tolerence*skip,minLength,streamers)

        update_history(possible,history,threshold,frameNumber)
    ## DEBUGGING ##
      # for i in possible:
      #   f = cv2.rectangle(frame,(int(i[0]),int(i[1])),(int(i[2]),int(i[3])),(255, 0, 0),2)
      # if len(possible)>0:
      #   IM.append(f)
      # else:
      #   IM.append(frame)
      # if frameNumber>105:
      #   remove_old_history(True,history,frameNumber,tolerence,minLength,streamers)
      #   break
      # for H in history:
      #   print(H)
    else:      
      remove_old_history(True,history,frameNumber,tolerence,minLength,streamers)
      break
  
  cap.release()
  cv2.destroyAllWindows()

  return streamers#,IM

"""##### RUN"""

#st = get_streamers('gdrive/MyDrive/third person shooter/30sec.mp4',8,100,0.8)
#print(st)

"""# COUNT NUMBER OF CHARACTERS IN THE EACH FRAME"""

def get_streamer_counts(st,frameNumber):
  cnt = 0
  for s in st:
    xmin,xmax,ymix,ymax,st,en = s
    if frameNumber>=st and frameNumber<=en:
      cnt+=1
  return cnt

def get_Number_Of_Characters_values(videoURL,skip):
  result = []
  st = get_streamers(videoURL,8,100,0.8,skip)
  cap = cv2.VideoCapture(videoURL)
  if (cap.isOpened()== False): 
    print("Error opening video stream or file")

  frameNumber = 0
  totalFrames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
  history = []
  while(cap.isOpened()):
    ret, frame = cap.read()
    frameNumber += 1
    lastRes=0
    if ret == True:
      if frameNumber % skip == 1 or frameNumber == totalFrames:
        frame_rgb = frame[..., ::-1]
        persons = Get_Persons(frame_rgb)
        dataframe = getDataFrame(persons)
        persons_cnt = dataframe.shape[0]
        streamers_cnt = get_streamer_counts(st,frameNumber)
        lastRes = max(persons_cnt-streamers_cnt,0)
        result.append(lastRes)
      else:
        result.append(lastRes)
    else:      
      break
  
  cap.release()
  cv2.destroyAllWindows()
  return result

#res = get_Number_Of_Characters_values('gdrive/MyDrive/third person shooter/30sec.mp4')